<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>1</h1>
    <h1>2</h1>
    <h1>3</h1>
    <h1>4</h1>
    <h1>5</h1>
    <h1>6</h1>
    <h1>7</h1>
    <h1>8</h1>
    <h1>9</h1>
    <h1>10</h1>
    <h1>11</h1>
    <h1>12</h1>
    <h1>13</h1>
    <h1>14</h1>
    <h1>15</h1>
    <h1>16</h1>
    <h1>17</h1>
    <h1>18</h1>
    <h1>19</h1>
    <h1>20</h1>
    <h1>21</h1>
    <h1>22</h1>
    <h1>23</h1>
    <h1>24</h1>
    <h1>25</h1>
    <h1>26</h1>
    <h1>27</h1>
    <h1>28</h1>
    <h1>29</h1>
    <h1>30</h1>
<script>
// 定义数字
var num = 0;
// 定义函数
function demo() {
    console.log(++num)
}
// 基于操作的节流：  防抖
// 定义定时器句柄
// var timebar;
// 高频时间 
// window.onscroll = function() {
//     // 执行函数
//     // demo();
//     // 基于操作的，在高频事件中，执行最后一次。
//     // 将函数放在定时器中，每次触发事件，取消执行，
//     // clearTimeout(timebar)
//     // 直到最后一次
//     // timebar = setTimeout(demo, 200)
//     // 这种基于操作的节流也被称为防抖

//     // 使用防抖函数
//     throttle(demo)
// }
// // 封装防抖(节流)函数
// function throttle(fn) {
//     // 清除定时器，
//     clearTimeout(fn.__timebar);
//     // 执行定时器
//     // 函数也属于对象，因此可以添加属性
//     fn.__timebar = setTimeout(fn, 200);
// }

// 定义锁
// var lock = false;
// 基于时间的节流
window.onscroll = function() {
    // 为true的时候不能执行
    // if (lock) {
    //     return;
    // }
    // // 设置锁
    // lock = true;
    // // demo();
    // // 在1秒之内，无论出发多少次，只能执行一次。
    // demo();
    // // 启动定时器
    // setTimeout(function() {
    //     // 解除锁
    //     lock = false;
    // }, 1000)

    // 节流函数
    throttle(demo);
}

// 节流器方法
function throttle(fn) {
    // 在函数自身添加锁
    if (fn.__lock) {
        // 被锁住了就不能执行
        return;
    }
    // 添加锁
    fn.__lock = true;
    // 执行函数
    fn();
    // 1秒之后解锁
    setTimeout(function() {
        fn.__lock = false;
    }, 1000)
}
</script>
</body>
</html>